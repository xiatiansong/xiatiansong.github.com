<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Django中的模型 - 夏天松的个人博客</title>
  <meta name="description" content="这篇文章主要介绍 Django 中模型的定义方法以及模型之间存在的几种映射关系。">
  <meta name="keywords" content="java, hadoop, hive, hbase, spark, linux, scala, python, mysql">
  <meta name="author" content="夏天松">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="360-site-verification" content="9b7a87a1d52051c96644f0a9b8b79898" />
  <meta name="sogou_site_verification" content="ofwXWFdthV"/>

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" >

  <link rel="canonical" href="http://blog.xiatiansong.com/2015/01/14/django-model">
  <link rel="stylesheet" href="/static/css/bootstrap.min.css" media="all">
  <link rel="stylesheet" href="/static/css/style.css" media="all">
  <link rel="stylesheet" href="/static/css/pygments.css" media="all">
  <link rel="stylesheet" href="/static/css/font-awesome.css" media="all">

  <!-- atom & rss feed -->
  <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="夏天松的个人博客 RSS Feed">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="夏天松的个人博客 ATOM Feed">
</head>


  <body>
    <div class="container">
      <!--[if lte IE 9]>
<div class="alert alert-warning">
  <p>Your Internet Explorer is not supported. Please upgrade your Internet Explorer to version 9+, or use latest <a href="http://www.google.com/chrome/" target="_blank" class="alert-link">Google chrome</a>、<a href="http://www.mozilla.org/firefox/" target="_blank" class="alert-link">Mozilla Firefox</a>.</p>
  <p>If you are using IE 9 or later, make sure you <a href="http://windows.microsoft.com/en-us/internet-explorer/use-compatibility-view#ie=ie-8" target="_blank" class="alert-link">turn off "Compatibility view"</a>.</p>
</div>
<![endif]-->
<header class="header">
  <div class="title"><a title="夏天松的个人博客" href="/">夏天松的个人博客</a></div>
  <ul class="nav navbar-nav navbar-right visible-lg visible-md">
    <li>
    <form id="search-form" class="form-group has-success visible-lg" role="form">
      <input type="text" class="form-control input-sm" placeholder="Search" id="query" style="width: 160px;">
    </form>
    </li>
    <li><a href="/archive.html" title="Archive"><span class='fa fa-archive fa-2x'></span></a></li>
    <li><a href="/categories.html" title="Categories"><span class='fa fa-navicon fa-2x'></span></a></li>
    <li><a href="/tags.html" title="Tags"><span class='fa fa-tags fa-2x'></span></a></li>
    <li><a href="/about.html" title="About"><span class='fa fa-user fa-2x'></span></a></li>
    
    <li><a href="https://github.com/xiatiansong" target="_blank" title="Github"><span class='fa fa-github fa-2x'></span></a></li>
    
    
    
    
    
    <li><a href="http://weibo.com/xiaotian120" target="_blank" title="Weibo"><span class="fa fa-weibo fa-2x"></span></a></li>
    

    <li><a href="/rss.xml" target="_blank" title="RSS"><span class='fa fa-rss fa-2x'></span></a></li>
  </ul>
</header>


      <div class="wrapper">
        <div class="row">
          <div id="search-loader" style="display:none;text-align:center">
            <img src="http://javachen-rs.qiniudn.com/images/loading.gif">
          </div>
          <div class="col-md-12">
  <article class="news-item">

      <h2  class="news-item"> Django中的模型  
        <time class="small">2015.01.14</time>
      </h2>

      <div><p>通过《<a href="/2014/01/11/how-to-create-a-django-site/">如何创建一个Django网站</a>》大概清楚了如何创建一个简单的 Django 网站，这篇文章主要是在此基础上介绍 Django 中模型的定义方法以及模型之间存在的几种映射关系。</p>

<h1 id="模型的定义">模型的定义</h1>

<ul>
<li>Django 中每一个 Model 都继承自 <code class="prettyprint">django.db.models.Model</code>。</li>
<li>在 Model 当中每一个属性 attribute 都代表一个数据库字段。</li>
<li>通过 Django Model API 可以执行数据库的增删改查, 而不需要写一些数据库的查询语句。</li>
</ul>

<p>在 <a href="/2014/01/11/how-to-create-a-django-site/">如何创建一个Django网站</a> 中创建的 List 模型定义如下：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">todo.models</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">django.contrib</span> <span class="kn">import</span> <span class="n">admin</span>

<span class="kn">import</span> <span class="nn">datetime</span>

<span class="c">#模型继承django.db.models.Model</span>
<span class="k">class</span> <span class="nc">List</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="c">#定义字段，每个字段都是 Field 类的子类</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">slug</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">SlugField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">editable</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">group</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Group</span><span class="p">)</span>

    <span class="c">#返回对一个对象的字符串表示</span>
    <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="c">#内部类，定义模型类元数据</span>
    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;name&quot;</span><span class="p">]</span>
        <span class="n">verbose_name_plural</span> <span class="o">=</span> <span class="s">&quot;Lists&quot;</span>

        <span class="c"># Prevents (at the database level) creation of two lists with the same name in the same group</span>
        <span class="n">unique_together</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;group&quot;</span><span class="p">,</span> <span class="s">&quot;slug&quot;</span><span class="p">)</span>
</code></pre></div>
<p>模型的字段可能的类型如下：</p>

<table><thead>
<tr>
<th style="text-align: left">字段名</th>
<th style="text-align: left">参数</th>
<th style="text-align: left">意义</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">AutoField</td>
<td style="text-align: left"></td>
<td style="text-align: left">一个能够根据可用ID自增的 IntegerField</td>
</tr>
<tr>
<td style="text-align: left">BooleanField</td>
<td style="text-align: left"></td>
<td style="text-align: left">一个真/假字段</td>
</tr>
<tr>
<td style="text-align: left">CharField</td>
<td style="text-align: left">(max_length)</td>
<td style="text-align: left">适用于中小长度的字符串。对于长段的文字，请使用 TextField</td>
</tr>
<tr>
<td style="text-align: left">CommaSeparatedIntegerField</td>
<td style="text-align: left">(max_length)</td>
<td style="text-align: left">一个用逗号分隔开的整数字段</td>
</tr>
<tr>
<td style="text-align: left">DateField</td>
<td style="text-align: left">([auto_now], [auto_now_add])</td>
<td style="text-align: left">日期字段</td>
</tr>
<tr>
<td style="text-align: left">DateTimeField</td>
<td style="text-align: left"></td>
<td style="text-align: left">时间日期字段,接受跟 DateField 一样的额外选项</td>
</tr>
<tr>
<td style="text-align: left">EmailField</td>
<td style="text-align: left"></td>
<td style="text-align: left">一个能检查值是否是有效的电子邮件地址的 CharField</td>
</tr>
<tr>
<td style="text-align: left">FileField</td>
<td style="text-align: left">(upload_to)</td>
<td style="text-align: left">一个文件上传字段</td>
</tr>
<tr>
<td style="text-align: left">FilePathField</td>
<td style="text-align: left">(path,[match],[recursive])</td>
<td style="text-align: left">一个拥有若干可选项的字段，选项被限定为文件系统中某个目录下的文件名</td>
</tr>
<tr>
<td style="text-align: left">FloatField</td>
<td style="text-align: left">(max_digits,decimal_places)</td>
<td style="text-align: left">一个浮点数，对应 Python 中的 float 实例</td>
</tr>
<tr>
<td style="text-align: left">ImageField</td>
<td style="text-align: left">(upload_to, [height_field] ,[width_field])</td>
<td style="text-align: left">像 FileField 一样，只不过要验证上传的对象是一个有效的图片。</td>
</tr>
<tr>
<td style="text-align: left">IntegerField</td>
<td style="text-align: left"></td>
<td style="text-align: left">一个整数。</td>
</tr>
<tr>
<td style="text-align: left">IPAddressField</td>
<td style="text-align: left"></td>
<td style="text-align: left">一个IP地址，以字符串格式表示（例如： &quot;24.124.1.30&quot; ）。</td>
</tr>
<tr>
<td style="text-align: left">NullBooleanField</td>
<td style="text-align: left"></td>
<td style="text-align: left">就像一个 BooleanField ，但它支持 None /Null 。</td>
</tr>
<tr>
<td style="text-align: left">PhoneNumberField</td>
<td style="text-align: left"></td>
<td style="text-align: left">它是一个 CharField ，并且会检查值是否是一个合法的美式电话格式</td>
</tr>
<tr>
<td style="text-align: left">PositiveIntegerField</td>
<td style="text-align: left"></td>
<td style="text-align: left">和 IntegerField 类似，但必须是正值。</td>
</tr>
<tr>
<td style="text-align: left">PositiveSmallIntegerField</td>
<td style="text-align: left"></td>
<td style="text-align: left">与 PositiveIntegerField 类似，但只允许小于一定值的值,最大值取决于数据库</td>
</tr>
<tr>
<td style="text-align: left">SlugField</td>
<td style="text-align: left"></td>
<td style="text-align: left">嵌条 就是一段内容的简短标签，这段内容只能包含字母、数字、下划线或连字符。通常用于 URL 中</td>
</tr>
<tr>
<td style="text-align: left">SmallIntegerField</td>
<td style="text-align: left"></td>
<td style="text-align: left">和 IntegerField 类似，但是只允许在一个数据库相关的范围内的数值（通常是-32,768到</td>
</tr>
<tr>
<td style="text-align: left">TextField</td>
<td style="text-align: left"></td>
<td style="text-align: left">一个不限长度的文字字段</td>
</tr>
<tr>
<td style="text-align: left">TimeField</td>
<td style="text-align: left"></td>
<td style="text-align: left">时分秒的时间显示。它接受的可指定参数与 DateField 和 DateTimeField 相同。</td>
</tr>
<tr>
<td style="text-align: left">URLField</td>
<td style="text-align: left"></td>
<td style="text-align: left">用来存储 URL 的字段。</td>
</tr>
<tr>
<td style="text-align: left">USStateField</td>
<td style="text-align: left"></td>
<td style="text-align: left">美国州名称缩写，两个字母。</td>
</tr>
<tr>
<td style="text-align: left">XMLField</td>
<td style="text-align: left">(schema_path)</td>
<td style="text-align: left">它就是一个 TextField ，只不过要检查值是匹配指定schema的合法XML。</td>
</tr>
</tbody></table>

<p>通用字段参数列表如下（所有的字段类型都可以使用下面的参数，所有的都是可选的。）：</p>

<table><thead>
<tr>
<th style="text-align: left">参数名</th>
<th style="text-align: left">意义</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left">null</td>
<td style="text-align: left">如果设置为 True 的话，Django将在数据库中存储空值为 NULL 。默认False 。</td>
</tr>
<tr>
<td style="text-align: left">blank</td>
<td style="text-align: left">如果是 True ，该字段允许留空，默认为 False 。</td>
</tr>
<tr>
<td style="text-align: left">choices</td>
<td style="text-align: left">一个包含双元素元组的可迭代的对象，用于给字段提供选项。</td>
</tr>
<tr>
<td style="text-align: left">db_column</td>
<td style="text-align: left">当前字段在数据库中对应的列的名字。</td>
</tr>
<tr>
<td style="text-align: left">db_index</td>
<td style="text-align: left">如果为 True ，Django会在创建表时对这一列创建数据库索引。</td>
</tr>
<tr>
<td style="text-align: left">default</td>
<td style="text-align: left">字段的默认值</td>
</tr>
<tr>
<td style="text-align: left">editable</td>
<td style="text-align: left">如果为 False ，这个字段在管理界面或表单里将不能编辑。默认为 True 。</td>
</tr>
<tr>
<td style="text-align: left">help_text</td>
<td style="text-align: left">在管理界面表单对象里显示在字段下面的额外帮助文本。</td>
</tr>
<tr>
<td style="text-align: left">primary_key</td>
<td style="text-align: left">如果为 True ，这个字段就会成为模型的主键。</td>
</tr>
<tr>
<td style="text-align: left">radio_admin</td>
<td style="text-align: left">如果 radio_admin 设置为 True 的话，Django 就会使用单选按钮界面。</td>
</tr>
<tr>
<td style="text-align: left">unique</td>
<td style="text-align: left">如果是 True ，这个字段的值在整个表中必须是唯一的。</td>
</tr>
<tr>
<td style="text-align: left">unique_for_date</td>
<td style="text-align: left">把它的值设成一个 DataField 或者 DateTimeField 的字段的名称，可以确保字段在这个日期内不会出现重复值。</td>
</tr>
<tr>
<td style="text-align: left">unique_for_month</td>
<td style="text-align: left">和 unique_for_date 类似，只是要求字段在指定字段的月份内唯一。</td>
</tr>
<tr>
<td style="text-align: left">unique_for_year</td>
<td style="text-align: left">和 unique_for_date 及 unique_for_month 类似，只是时间范围变成了一年。</td>
</tr>
<tr>
<td style="text-align: left">verbose_name</td>
<td style="text-align: left">除 ForeignKey 、 ManyToManyField 和 OneToOneField 之外的字段都接受一个详细名称作为第一个位置参数。</td>
</tr>
</tbody></table>

<p><strong>主键和唯一性</strong>：</p>

<p>如果你没有明确指定，Django会自动生成主键 id（AutoField，自增整数，如果你希望有更多的控制主键，只需要在某个变量上指定 <code class="prettyprint">primary_key = True</code>，这个变量会取代 id 成为这个表的主键。类似于 SQL 中的 UNIQUE 索引，Django 也提供了 <code class="prettyprint">unique=True</code> 的参数</p>

<p>定义了模型之后，可以用下面校验模型：</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>python manage.py validate
    System check identified no issues <span class="o">(</span>0 silenced<span class="o">)</span>.
</code></pre></div>
<p>validate 命令检查你的模型的语法和逻辑是否正确。 如果一切正常，你会看到 <code class="prettyprint">System check identified no issues (0 silenced).</code>消息。如果出错，请检查你输入的模型代码。 错误输出会给出非常有用的错误信息来帮助你修正你的模型。</p>

<p>模型确认没问题了，运行下面的命令来生成建表语句：</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># 在 django1.7之后先执行这个命令</span>
<span class="nv">$ </span>python manage.py migrate
<span class="nv">$ </span>python manage.py makemigrations

<span class="nv">$ </span>python manage.py  sql todo
    CommandError: App <span class="s1">&#39;todo&#39;</span> has migrations. Only the sqlmigrate and sqlflush commands can be used when an app has migrations.

<span class="c"># 出现上面错误，则删除 todo/migrations</span>
<span class="nv">$ </span>rm -rf todo/migrations

<span class="c"># 再次执行，可以看到建表语句</span>
<span class="nv">$ </span>python manage.py sql todo
</code></pre></div>
<p>当然，你也可以执行下面的命令：</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># 显示 CREATE TABLE 语句</span>
<span class="nv">$ </span>python manage.py sql todo  

<span class="c">#输出为应用定义的任何 custom SQL statements ( 例如表或约束的修改 )</span>
<span class="nv">$ </span>python manage.py sqlcustom todo

<span class="c">#为应用输出必要的 DROP TABLE </span>
<span class="nv">$ </span>python manage.py sqlclear todo    

<span class="c">#为应用输出 CREATE INDEX 语句</span>
<span class="nv">$ </span>python manage.py sqlindexes todo   

<span class="c"># sqlclear和sql的组合 </span>
<span class="nv">$ </span>python manage.py sqlreset todo  
</code></pre></div>
<h1 id="模型之间的关系">模型之间的关系</h1>

<h2 id="多对一">多对一</h2>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">author</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
</code></pre></div>
<p>Django 的外键表现很直观，其主要参数就是它要引用的模型类；但是注意要把被引用的类放在前面。不过，如果不想留意顺序，也可以用字符串代替。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">author</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s">&quot;Author&quot;</span><span class="p">)</span>
  <span class="c">#if Author class is defined in another file myapp/models.py</span>
  <span class="c">#author = models.ForeignKey(&quot;myapp.Author&quot;)</span>

<span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
   <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</code></pre></div>
<p>如果要引用自己为外键，可以设置 <code class="prettyprint">models.ForeignKey(&quot;self&quot;)</code> ，这在定义层次结构等类似场景很常用，比如 Employee 类可以具有类似 supervisor 或是 hired_by 这样的属性。</p>

<p>外键 ForeignKey 只定义了关系的一端，但是另一端可以根据关系追溯回来，因为这是一种多对一的关系，多个子对象可以引用同一个父对象，而父对象可以访问到一组子对象。看下面的例子：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c">#取一本书“Moby Dick”</span>
<span class="n">book</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&quot;Moby Dick&quot;</span><span class="p">)</span>

<span class="c">#取作者名字</span>
<span class="n">author</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">author</span>

<span class="c">#获取这个作者所有的书</span>
<span class="n">books</span> <span class="o">=</span> <span class="n">author</span><span class="o">.</span><span class="n">book_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</code></pre></div>
<p>这里从 Author 到 Book 的反向关系式通过 <code class="prettyprint">Author.book_set</code> 属性来表示的（这是一个manager对象），是由 ORM 自动添加的，可以通过在 ForeignKey 里指定 <code class="prettyprint">related_name</code> 参数来改变它的名字。比如：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">author</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s">&quot;Author&quot;</span><span class="p">,</span> <span class="n">related_name</span> <span class="o">=</span> <span class="s">&quot;books&quot;</span><span class="p">)</span>

<span class="c">#获取这个作者所有的书</span>
<span class="n">books</span> <span class="o">=</span> <span class="n">author</span><span class="o">.</span><span class="n">books</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</code></pre></div>
<p>对简单的对象层次来说， <code class="prettyprint">related_name</code> 不是必需的，但是更复杂的关系里，比如当有多个 ForeignKey 的时候就一定要指定了。</p>

<h2 id="多对多">多对多</h2>

<p>上面的例子假设的是一本书只有一个作者，一个作者有多本书，所以是多对一的关系；但是如果一本书也有多个作者呢？这就是多对多的关系；由于SQL没有定义这种关系，必须通过外键用它能理解的方式实现多对多</p>

<p>这里 Django 提供了第二种关系对象映射变量 <code class="prettyprint">ManyToManyField</code>，语法上来讲， 这和 ForeignKey 是一模一样的，你在关系的一端定义，把要关联的类传递进来，ORM 会自动为另一端生成使用这个关系必要的方法和属性</p>

<p>不过由于 ManyToManyField 的特性，在哪一端定义它通常都没有关系，因为这个关系是对称的。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>

<span class="c">#获取一本书</span>
<span class="n">book</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&quot;Python Web Dev Django&quot;</span><span class="p">)</span>

<span class="c">#获取该书所有的作者</span>
<span class="n">authors</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">author_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="c">#获取第三个作者出版过的所有的书</span>
<span class="n">books</span> <span class="o">=</span> <span class="n">authors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">book_set</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</code></pre></div>
<p>ManyToManyField 的秘密在于它在背后创建了一张新的表来满足这类关系的查询的需要，而这张表用的则是 SQL 外键，其中每一行都代表了两个对象的一个关系，同时包含了两端的外键</p>

<p>这张查询表在 Django ORM 中一般是隐藏的，不可以单独查询，只能通过关系的某一端查询；不过可以在 MTMField 上指定一个特殊的选项 through 来指向一个显式的中间模型类，更方便你的手动管理关系的两端</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">,</span> <span class="n">through</span> <span class="o">=</span> <span class="s">&quot;Authoring&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Authoring</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">collaboration_type</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">book</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Book</span><span class="p">)</span>
  <span class="n">author</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>
</code></pre></div>
<p>查询 Author 和 Book 的方法和之前完全一样，另外还能构造对 authoring 的查询：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">chan_essay_compilations</span> <span class="o">=</span> <span class="n">Book</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
    <span class="n">author__name__endswith</span> <span class="o">=</span> <span class="s">&#39;Chun&#39;</span>
    <span class="n">authoring__collaboration_type</span> <span class="o">=</span> <span class="s">&#39;essays&#39;</span>
<span class="p">)</span>
</code></pre></div>
<h2 id="一对一">一对一</h2>

<p>类似的，Django 提供了 OneToOneField 属性，几乎和 ForeignKey 一样，接受一个参数（要关联的类或者&quot;self&quot;），同样也接受一个可选参数 related_name ，这样就可以在两个相同的类里区分出多个这样的关系来。</p>

<p>不同的是，OTOField 没有在反向关系中添加 <code class="prettyprint">reverse manager</code>，而只是增加了一个普通属性而已，因为关系的另一端一定只有一个对象。</p>

<p>这种关系最常用的是用来支持对象组合或者是拥有关系，所以相比现实世界，它更加面向对象一点。</p>

<p>在 Django直接支持模型继承之前，OTOField 主要是用来实现模型继承，而现在，则是转向对这个特性的幕后支持了。</p>

<p>关于定义关系的最后一点，ForeignKey 和 MTMField 都可以指定一个 <code class="prettyprint">limit_choices_to</code>参数，这个参数接受一个字典，键值对是查询的关键字和值</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SmithBook</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">,</span> <span class="n">limit_choices_to</span><span class="o">=</span><span class="p">{</span>
    <span class="s">&#39;name__endswith&#39;</span> <span class="p">:</span> <span class="s">&#39;Smith&#39;</span>
  <span class="p">})</span>
</code></pre></div>
<p>这个例子中，Book 模型就只能和姓 Smith 的 Authors 类一起工作。当然这个问题最好用另一种解决方案-------ModelChoiceField,ModelMultipleChoiceField</p>

<h1 id="模型继承">模型继承</h1>

<p>Django目前支持2种不同的继承方式，每种都有自身的优缺点：</p>

<ul>
<li>抽象基础类 -- 纯Python的继承</li>
<li>多表继承</li>
</ul>

<p>第一种方式的例子：</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">genre</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">num_pages</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntergerField</span><span class="p">()</span>
  <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span>

  <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
    <span class="n">abstract</span> <span class="o">=</span> <span class="bp">True</span>

<span class="k">class</span> <span class="nc">SmithBook</span><span class="p">(</span><span class="n">Book</span><span class="p">):</span>
  <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">,</span> <span class="n">limit_choices_to</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;name_endswith&#39;</span><span class="p">:</span> <span class="s">&#39;Smith&#39;</span>
  <span class="p">})</span>
</code></pre></div>
<p>这里代码的关键是 <code class="prettyprint">abstract = True</code> 设置， 指明了 Book 是一个抽象基础类，只是用来为它实际的模型子类提供属性而存在的。</p>

<p>再说说多表继承， 同样还是会用到 Python的类继承， 但是不再需要 <code class="prettyprint">abstract = True</code> 这个 Meta 类选项了。</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Author</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Book</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
  <span class="n">title</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">genre</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
  <span class="n">num_pages</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>
  <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">__unicode__</span><span class="p">(</span><span class="n">Book</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span>

<span class="k">class</span> <span class="nc">SmithBook</span><span class="p">(</span><span class="n">Book</span><span class="p">):</span>
  <span class="n">authors</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ManyToManyField</span><span class="p">(</span><span class="n">Author</span><span class="p">,</span> <span class="n">limit_choices_to</span><span class="o">=</span><span class="p">{</span>
    <span class="s">&#39;name_endswith&#39;</span><span class="p">:</span><span class="s">&#39;Smith&#39;</span>
  <span class="p">})</span>
</code></pre></div>
<p>在检查模型实例或是查询的时候，多表继承和前面看到的一样，子类会从父类中继承所有的属性和方法。多表继承其实就是对普通的 <code class="prettyprint">has-a</code> 关系（或者说 对象组合 ）的一个方便的包装。</p>

<blockquote>
<p>多表继承和抽象类继承不同之处在于，在一个空数据库和这个 models.py 文件上运行 <code class="prettyprint">manage.py syncdb</code> 会<strong>创建三张表 Author, Book, SmithBook</strong>，而抽象基础类的情况下，<strong>只创建了 Author, SmithBook 两张表</strong>。</p>
</blockquote>

<h1 id="meta-嵌套类">Meta 嵌套类</h1>

<p>模型里定义的变量 fields 和关系 relationships 提供了数据库的布局以及稍后查询模型时要用的变量名--经常你还需要添加<strong>unicode</strong> 和 get_absolute_url 方法或是重写 内置的 save 和 delete方法。</p>

<p>然而，模型的定义还有第三个方面--告知Django关于这个模型的各种元数据信息的嵌套类 Meta，Meta 类处理的是模型的各种元数据的使用和显示：</p>

<ul>
<li>比如在一个对象对多个对象是，它的名字应该怎么显示</li>
<li>查询数据表示默认的排序顺序是什么</li>
<li>数据表的名字是什么</li>
<li>多变量唯一性 （这种限制没有办法在每个单独的变量声明上定义）</li>
</ul>

<p>Meta类有以下属性：</p>

<ul>
<li><code class="prettyprint">abstract</code>：定义当前的模型类是不是一个抽象类。</li>
<li><code class="prettyprint">app_label</code>：这个选项只在一种情况下使用，就是你的模型类不在默认的应用程序包下的 models.py 文件中，这时候你需要指定你这个模型类是那个应用程序的</li>
<li><code class="prettyprint">db_table</code>：指定自定义数据库表名</li>
<li><code class="prettyprint">db_tablespace</code>：指定这个模型对应的数据库表放在哪个数据库表空间</li>
<li><code class="prettyprint">get_latest_by</code>：由于 Django 的管理方法中有个 <code class="prettyprint">lastest()</code>方法，就是得到最近一行记录。如果你的数据模型中有 DateField 或 DateTimeField 类型的字段，你可以通过这个选项来指定 <code class="prettyprint">lastest()</code> 是按照哪个字段进行选取的。</li>
<li><code class="prettyprint">managed</code>：由于 Django 会自动根据模型类生成映射的数据库表，如果你不希望 Django 这么做，可以把 managed 的值设置为 False。</li>
<li><code class="prettyprint">order_with_respect_to</code>：这个选项一般用于多对多的关系中，它指向一个关联对象。就是说关联对象找到这个对象后它是经过排序的。指定这个属性后你会得到一个 <code class="prettyprint">get_XXX_order()</code> 和 <code class="prettyprint">set_XXX_order()</code> 的方法,通过它们你可以设置或者返回排序的对象。</li>
<li><code class="prettyprint">ordering</code>：定义排序字段</li>
<li><code class="prettyprint">permissions</code>：为了在 Django Admin 管理模块下使用的，如果你设置了这个属性可以让指定的方法权限描述更清晰可读</li>
<li><code class="prettyprint">proxy</code>：为了实现代理模型使用的</li>
<li><code class="prettyprint">unique_together</code>：定义多个字段保证数据的唯一性</li>
<li><code class="prettyprint">verbose_name</code>：给你的模型类起一个更可读的名字</li>
<li><code class="prettyprint">verbose_name_plural</code>：这个选项是指定模型的复数形式是什么</li>
</ul>

<h1 id="参考文章">参考文章</h1>

<ul>
<li><a href="http://www.c77cc.cn/article-64.html">Django 数据模型的字段列表整理</a></li>
<li><a href="http://www.tuicool.com/articles/vU7vIz">跟我一起Django - 04 定义和使用模型</a></li>
<li><a href="http://iluoxuan.iteye.com/blog/1703061">django的模型总结</a></li>
</ul>
</div>

      <!--
      <div id="pay" style="text-align:center;">
        ----EOF-----
        <br>
        <section>
  <h4>Sponsor</h4>
	<img src="http://javachen-rs.qiniudn.com/images/alipay.png" width="150/">
  <p class="small">觉得此博客对你有帮助，支付宝扫码赞助吧</p>
</section>

      </div>
      -->
      <p class="meta">
      	
            Categories:
      	    
          	<a class="btn btn-default btn-xs" href="/categories.html#python">python</a>
          
      	

      	
            Tags:
      	    
          	<a class="btn btn-default btn-xs" href="/tags.html#python">python</a>
          
          	<a class="btn btn-default btn-xs" href="/tags.html#django">django</a>
          
      	
      </p>
	</article>

	<ul class="pager">
	  
	  <li class="previous"><a class="btn btn-xs" href="/2015/01/09/angular-phonecat-examples" title="AngularJS PhoneCat代码分析">&larr; Prev</a></li>
	  
	  
	  <li class="next disabled"><a class="btn btn-xs" href="#">Next &rarr;</a></li>
	  
	</ul>

  
<div id="comments">
  <div class="ds-thread" data-thread-key="/2015/01/14/django-model"  data-title="Django中的模型 - 夏天松的个人博客"></div>
</div>



</div>

        </div>
      </div>

      <footer class="footer text-center">
  <p>&copy; 2009-2015 <a href="/" target="_blank" title="86后，工作在深圳；Java程序员、Hadoop工程师；主要关注Java、Scala、Hadoop、Kettle、关注大数据处理技术。">夏天松</a>. With Help from <a href="//jekyllrb.com/" target="_blank" title="Transform your plain text into static websites and blogs.">Jekyll</a> and <a href="//getbootstrap.com/" target="_blank" title="Bootstrap is the most popular HTML, CSS, and JS framework for developing responsive, mobile first projects on the web.">Bootstrap</a>, theme from <a href="http://havee.me/" target="_blank" title="http://havee.me/">Havee</a>.

  <span style="float:right;"><a href="/about.html">About</a></span>

	
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254098866'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1254098866' type='text/javascript'%3E%3C/script%3E"));</script>




  </p>
  <div id="toTop" style="display: block;">
    <a href="#">▲</a><a href="#footer">▼</a>
  </div>
</footer>

    </div>

    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>
    <script src="/static/js/core.js"></script>

    
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254098866'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1254098866' type='text/javascript'%3E%3C/script%3E"));</script>




    
    <!-- duoshuo Begin -->
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"xiaotian120"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] ||
        document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
    </script>
    <!-- duoshuo End -->
    
  </body>
</html>
