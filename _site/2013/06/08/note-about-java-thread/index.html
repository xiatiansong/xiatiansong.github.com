<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Java笔记：多线程 - 天松的个人博客</title>
  <meta name="description" content="多线程间堆空间共享，栈空间独立。堆存的是地址，栈存的是变量（如：局部变量）。多线程共同访问的同一个对象（临界资源），如果破坏了不可分割的操作（原子操作），就会造成数据不一致的情况。">
  <meta name="keywords" content="java,thread">
  <meta name="author" content="天松">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="360-site-verification" content="9b7a87a1d52051c96644f0a9b8b79898" />
  <meta name="sogou_site_verification" content="ofwXWFdthV"/>

  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" >

  <link rel="canonical" href="http://blog.xiatiansong.com/2013/06/08/note-about-java-thread">
  <link rel="stylesheet" href="/static/css/bootstrap.min.css" media="all">
  <link rel="stylesheet" href="/static/css/style.css" media="all">
  <link rel="stylesheet" href="/static/css/pygments.css" media="all">
  <link rel="stylesheet" href="/static/css/font-awesome.css" media="all">

  <!-- atom & rss feed -->
  <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="天松的个人博客 RSS Feed">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="天松的个人博客 ATOM Feed">
</head>


  <body>
    <div class="container">
      <!--[if lte IE 9]>
<div class="alert alert-warning">
  <p>Your Internet Explorer is not supported. Please upgrade your Internet Explorer to version 9+, or use latest <a href="http://www.google.com/chrome/" target="_blank" class="alert-link">Google chrome</a>、<a href="http://www.mozilla.org/firefox/" target="_blank" class="alert-link">Mozilla Firefox</a>.</p>
  <p>If you are using IE 9 or later, make sure you <a href="http://windows.microsoft.com/en-us/internet-explorer/use-compatibility-view#ie=ie-8" target="_blank" class="alert-link">turn off "Compatibility view"</a>.</p>
</div>
<![endif]-->
<header class="header">
  <div class="title"><a title="天松的个人博客" href="/">天松的个人博客</a></div>
  <ul class="nav navbar-nav navbar-right visible-lg visible-md">
    <li>
    <form id="search-form" class="form-group has-success visible-lg" role="form">
      <input type="text" class="form-control input-sm" placeholder="Search" id="query" style="width: 160px;">
    </form>
    </li>
    <li><a href="/archive.html" title="Archive"><span class='fa fa-archive fa-2x'></span></a></li>
    <li><a href="/categories.html" title="Categories"><span class='fa fa-navicon fa-2x'></span></a></li>
    <li><a href="/tags.html" title="Tags"><span class='fa fa-tags fa-2x'></span></a></li>
    <li><a href="/about.html" title="About"><span class='fa fa-user fa-2x'></span></a></li>
    
    <li><a href="https://github.com/xiatiansong" target="_blank" title="Github"><span class='fa fa-github fa-2x'></span></a></li>
    
    
    
    
    
    <li><a href="http://weibo.com/xiaotian120" target="_blank" title="Weibo"><span class="fa fa-weibo fa-2x"></span></a></li>
    

    <li><a href="/rss.xml" target="_blank" title="RSS"><span class='fa fa-rss fa-2x'></span></a></li>
  </ul>
</header>


      <div class="wrapper">
        <div class="row">
          <div id="search-loader" style="display:none;text-align:center">
            <img src="http://javachen-rs.qiniudn.com/images/loading.gif">
          </div>
          <div class="col-md-12">
  <article class="news-item">

      <h2  class="news-item"> Java笔记：多线程  
        <time class="small">2013.06.08</time>
      </h2>

      <div><p>线程：进程中并发的一个顺序执行流程。</p>

<p>并发原理：CPU分配时间片，多线程交替运行。宏观并行，微观串行。</p>

<p>多线程间堆空间共享，栈空间独立。堆存的是地址，栈存的是变量（如：局部变量）。</p>

<p>创建线程两种方式：继承Thread类或实现Runnable接口。</p>

<p>Thread对象代表一个线程。</p>

<p>多线程共同访问的同一个对象（临界资源），如果破坏了不可分割的操作（原子操作），就会造成数据不一致的情况。</p>

<h1 id="线程状态图">线程状态图</h1>

<p><img src="http://javachen-rs.qiniudn.com/images/2014/thread-state.jpg" alt=""></p>

<p>说明：<br>
线程共包括以下5种状态。</p>

<ul>
<li>1. 新建状态(New)： 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li>
<li>2. 就绪状态(Runnable)： 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li>
<li>3. 运行状态(Running)： 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li>
<li>4. 阻塞状态(Blocked)： 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

<ul>
<li>(01) 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。</li>
<li>(02) 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li>
<li>(03) 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li>
</ul></li>
<li>5. 死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ul>

<h1 id="thread和runnable">Thread和Runnable</h1>

<p>Runnable 是一个接口，该接口中只包含了一个run()方法。它的定义如下：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div>
<p>我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。</p>

<p>Thread 是一个类。Thread本身就实现了Runnable接口。它的声明如下：</p>
<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Thread</span> <span class="kd">implements</span> <span class="n">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Thread</span><span class="o">()</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">target</span><span class="o">)</span> <span class="o">{}</span>
    <span class="kd">public</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">ThreadGroup</span> <span class="n">group</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">target</span><span class="o">){}</span>
    <span class="kd">public</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">){}</span>
    <span class="kd">public</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">ThreadGroup</span> <span class="n">group</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">){}</span>
    <span class="kd">public</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">target</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">){}</span>
    <span class="kd">public</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">ThreadGroup</span> <span class="n">group</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">target</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">){}</span>
    <span class="kd">public</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">ThreadGroup</span> <span class="n">group</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">target</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">,</span><span class="kt">long</span> <span class="n">stackSize</span><span class="o">){}</span>
<span class="o">}</span>
</code></pre></div>
<p><strong>相同点</strong>：</p>

<p>都是“多线程的实现方式”。</p>

<p><strong>不同点</strong>：</p>

<p>Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。</p>

<p>此外，Runnable还可以用于“资源的共享”。即，<strong>多个线程都是基于某一个Runnable对象建立的</strong>，它们会共享这个Runnable对象上的资源。</p>

<h1 id="start()-和-run()">start() 和 run()</h1>

<p>start()：它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。</p>

<p>run()：和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！</p>

<h1 id="synchronized">synchronized</h1>

<p>在java中，任何对象都有一个互斥锁标记，用来分配给线程。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">synchronized(o){

}
</code></pre></div>
<p>对o（o是临界资源）加锁的同步代码块，只有拿到o的锁标记的线程，才能进入对o加锁的同步代码块，退出同步代码块时，会自动释放o的锁标记。</p>

<p>synchronized的同步方法，如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">public synchronized void fn(){

} 
</code></pre></div>
<p>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。</p>

<p>不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。</p>

<p>例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。</p>

<p><strong>对访问该方法的当前对象（this）加锁；哪个线程能拿到该对象（临界资源）的锁，哪个线程就能调用该对象（临界资源）的同步方法。</strong></p>

<p>一个线程，可以同时拥有多个对象的锁标记。</p>

<h1 id="wait(),-notify(),-notifyall()">wait(), notify(), notifyAll()</h1>

<p>在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让<strong>当前线程</strong>进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。</p>

<p>notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！</p>

<p>在java中，任何对象都有一个锁池，用来存放等待该对象锁标记的线程，线程阻塞在对象锁池中时，不会释放其所拥有的其它对象的锁标记。</p>

<p>在java中，任何对象都有一个等待队列，用来存放线程，线程t1对（让）o调用wait方法,必须放在对o加锁的同步代码块中! </p>

<ul>
<li>1.t1会释放其所拥有的所有锁标记;</li>
<li>2.t1会进入o的等待队列</li>
</ul>

<p>t2对（让）o调用notify/notifyAll方法,也必须放在对o加锁的同步代码块中! 会从o的等待队列中释放一个/全部线程，对t2毫无影响，t2继续执行。</p>

<h1 id="yield()">yield()</h1>

<p>yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！</p>

<p><strong>wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。</strong></p>

<h1 id="sleep()">sleep()</h1>

<p>sleep() 定义在Thread.java中。</p>

<p>sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。</p>

<p><strong>wait()会释放对象的同步锁，而sleep()则不会释放锁。</strong></p>

<h1 id="join()">join()</h1>

<p>join() 定义在Thread.java中。</p>

<p>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。</p>

<h1 id="interrupt()">interrupt()</h1>

<p>interrupt()的作用是中断本线程。</p>

<p>本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。</p>

<p>如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。</p>

<p>如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。</p>

<p>如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。</p>

<p><strong>interrupt()常常被用来终止“阻塞状态”线程。</strong></p>

<p>interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。</p>

<p>区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。</p>

<h1 id="线程优先级">线程优先级</h1>

<p>java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。</p>

<p>java 中有两种线程：用户线程和守护线程。可以通过isDaemon()</p>

<p>方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。</p>

<p>用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。</p>
</div>

      <!--
      <div id="pay" style="text-align:center;">
        ----EOF-----
        <br>
        <section>
  <h4>Sponsor</h4>
	<img src="http://javachen-rs.qiniudn.com/images/alipay.png" width="150/">
  <p class="small">觉得此博客对你有帮助，支付宝扫码赞助吧</p>
</section>

      </div>
      -->
      <p class="meta">
      	
            Categories:
      	    
          	<a class="btn btn-default btn-xs" href="/categories.html#java">java</a>
          
      	

      	
            Tags:
      	    
          	<a class="btn btn-default btn-xs" href="/tags.html#java">java</a>
          
          	<a class="btn btn-default btn-xs" href="/tags.html#thread">thread</a>
          
      	
      </p>
	</article>

	<ul class="pager">
	  
	  <li class="previous"><a class="btn btn-xs" href="/2013/06/08/java-collection-framework" title="Java笔记：集合框架实现原理">&larr; Prev</a></li>
	  
	  
	  <li class="next"><a class="btn btn-xs" href="/2013/06/09/note-about-java-factory-model" title="Java笔记：工厂模式">Next &rarr;</a></li>
	  
	</ul>

  
<div id="comments">
  <div class="ds-thread" data-thread-key="/2013/06/08/note-about-java-thread"  data-title="Java笔记：多线程 - 天松的个人博客"></div>
</div>



</div>

        </div>
      </div>

      <footer class="footer text-center">
  <p>&copy; 2009-2015 <a href="/" target="_blank" title="86后，工作在深圳；Java程序员、Hadoop工程师；主要关注Java、Scala、Hadoop、Kettle、关注大数据处理技术。">天松</a>. With Help from <a href="//jekyllrb.com/" target="_blank" title="Transform your plain text into static websites and blogs.">Jekyll</a> and <a href="//getbootstrap.com/" target="_blank" title="Bootstrap is the most popular HTML, CSS, and JS framework for developing responsive, mobile first projects on the web.">Bootstrap</a>, theme from <a href="http://havee.me/" target="_blank" title="http://havee.me/">Havee</a>.

  <span style="float:right;"><a href="/about.html">About</a></span>

	
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254098866'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1254098866' type='text/javascript'%3E%3C/script%3E"));</script>




  </p>
  <div id="toTop" style="display: block;">
    <a href="#">▲</a><a href="#footer">▼</a>
  </div>
</footer>

    </div>

    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>
    <script src="/static/js/core.js"></script>

    
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254098866'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/z_stat.php%3Fid%3D1254098866' type='text/javascript'%3E%3C/script%3E"));</script>




    
    <!-- duoshuo Begin -->
    <script type="text/javascript">
      var duoshuoQuery = {short_name:"xiaotian120"};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = 'http://static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] ||
        document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
    </script>
    <!-- duoshuo End -->
    
  </body>
</html>
